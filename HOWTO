BAS uses lexical language to create a lexicon, and binds 
everything up into a static library 'libbas.a'. This 
makes it quite fast in execution, and portable, for easy 
inclusion in other programs.

However this makes it hugely complex from an outsiders 
point of view, and still quite easy to "miss a spot" 
when adding something more complex, even for someone who 
knows the code.

Things to know: everything is (mostly) organised alpha-
betically, and in structures that follow that exact 
same order. Although not a requirement, that also 
extends to the order of coded functions in 'bas.c' and 
(especially) in 'statement.c'.

Make sure you edit 'token.l' _NOT_ 'token.c', or you 
will loose your work when you do edit 'token.l'.

If things are not working, 'printf' is often your only 
friend, as 'FS_put' (BAS terminal output) is only 
available in 'bas.c' and 'fs.c'. 'statement.c' is 
included directly into 'bas.c' around line 1564.

If your addition is a generic one, or a command line 
switch, make sure it is added to _BOTH_ Bas v2.5+ _AND_ 
Bas v2.5pw+.

If your addition is and extention to the ANSI BASIC 
language (eg. HPLOT in Apple Integer BASIC), add it 
_ONLY_ to Bas v2.5pw+. Check 'ram.h' and 'strict.h'.

After performing one of the following additions further 
down this document:
 o in 'bas.1.in', 'bas.1' (only generated by configure): 
 - add new command to upper section if its a statement, 
   or to the lower section if its a function.
 o '*.1':
 - if its a v2.5pw+ addition, add the same as above to 
   the approiate man pages.
 - if its a command line switch, thats at the top _AND_ 
   the bottom of _EVERY_ man page.
 o '*.po':
 - edit or add, if you know a language besides English.
 o 'NEWS':
 - add short description
 o 'HOWTO':
 - if its worth it, add a description of the addition in 
   the same format.


ADDITIONS:

To add data type:
 o in 'token.h':
 - add token type to 'enum TokenType' in alphabetical 
   order (line 85-267).
   eg. T_BININTEGER
 - add C comment to 'struct Token' under 'union' in 
   the same order (line 277-453) and append variable 
   name or structure if need be.
   eg.  /* T_BININTEGER         */ long int bininteger;
 o in 'token.l':
 - add a flex data type token (grep/sed/regex) 
   recognition string (line 78-101)
   eg. BININTEGER	&B[01]+
 - add a flex rule for that data type token (line 107
   -1213). eg. line 172-185
   {BININTEGER}    	{
			  int overflow;
			  long int n;

                	  n=Value_vali(yytext,(char**)0,&overflow);
                	  if (overflow)
                	  {
                	    if (cur) cur->u.junk=yytext[0];
                	    yyless(1);
                            return T_JUNK;
                	  }
                	  if (cur) cur->u.bininteger=n;
                	  return T_BININTEGER;
                	}
 - in the same order as in 'token.h', add a 'case' 
   senario in 'Token_destroy' (line 1370-1550)
   eg. case T_BININTEGER:        break;
 - in the same order as in 'token.h', add a line to 
   'table' in 'Token_toString' (line 1570-1751)
   eg. /* T_BININTEGER         */ {(const char*)0,0},
 - add a 'case' senario in 'switch (token->type)' 
   (line 1370-1550). eg,
      case T_BININTEGER: String_appendBinary(s,"&b%s",token->u.bininteger); break;
 o in 'str.h' and 'str.c':
 - if your data type requires its own function to 
   produce output in a listing, add them to . eg.
   extern int String_appendBinary(struct String *this, const char *fmt, long int arg_li);
 - Try to keep any further required functions seperate 
   from the standard BAS functions. eg.
   extern int BAS_ultostr(unsigned long value, char *string, int base);
 o in 'value.c':
 - if you data type is not an integer, but needs to be 
   resolved to an integer, add an 'else' clause to the 
   function 'Value_vali'. eg.
   else if (*s=='&' && tolower(*(s+1))=='b') n=strtoul(s+2,end,2);
 - if not, find or create the appropriate function in 
   'value.c'.
 - if you create a function, dont forget to add the 
   proto-type to 'value.h'.
 o (finally) in 'bas.c':
 - add a clause to LR0 'eval' (line 500-840) _AND_ 
   !LR0 'eval8'. eg. (look for)
   'else if (ip==T_BININTEGER)' (line 625)  _AND_ 
   'case T_BININTEGER:' (line 999)


To add simple statements:
 o in 'token.h':
 - add token type to 'enum TokenType' in alphabetical 
   order (line 85-267).
   eg. T_CHAIN
 - add C comment to 'struct Token' under 'union' in 
   the same order (line 277-453) and append variable 
   name or structure if need be.
   eg.  /* T_CHAIN              */
 o in 'token.l':
 - add a flex rule (grep/sed/regex) for the token 
   (line 107-1213). eg. line 254-260
"chain"          	{
                          if (cur)
                          {
                            cur->statement=stmt_CHAIN;
                          }
                          return T_CHAIN;
                        }
 - in the same order as in 'token.h', add a 'case' 
   senario in 'Token_destroy' (line 1370-1550)
   eg. case T_CHAIN:             break;
 - in the same order as in 'token.h', add a line to 
   'table' in 'Token_toString' (line 1570-1751)
   eg. /* T_CHAIN              */ {"chain",1},
 o in 'statement.c':
 - add the appropriate statement function. eg. line 3500
   struct Value *stmt_CHAIN(struct Value *value)
 o in 'statement.h':
 - add the appropriate function prototype. eg. line 45
   extern struct Value *stmt_CHAIN(struct Value *value);


To add complex statements:
 o 
 o 


To add functions:
 o 
 o 


To add graphics:
 o start a 'gfx.c' and 'gfx.h'
 o check 'ram.h' and 'strict.h'
 o add "opt-out" to 'configure.in' and 'config.in'


To add sound:
 o start a 'sfx.c' and 'sfx.h'
 o check 'ram.h' and 'strict.h'
 o add "opt-out" to 'configure.in' and 'config.in'
